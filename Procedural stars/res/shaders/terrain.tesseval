#version 410 core
layout(triangles, equal_spacing, ccw) in;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;
uniform int u_showLod;

uniform sampler2D u_noise;

in TSC {
    vec3 position;
    vec3 normal;
    vec3 color;
} vertex_in[];

out TES {
    vec3 position;
    vec3 normal;
    vec3 color;
} vertex_out;

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2);
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2);
float triplanar(vec3 pos);
vec2 coord(vec3 pos);
void main()
{
    // consts
    const float maxHeight = 400;

//    // vertex pos
//    vec3 pos = interpolate3D(vertex_in[0].position, vertex_in[1].position, vertex_in[2].position);
//    float height = noise(normalize(pos)*20) * 400;
//    pos += normalize(pos) * height;
    vec3 pos = interpolate3D(vertex_in[0].position, vertex_in[1].position, vertex_in[2].position);
    //pos += 800 * normalize(pos) * texture2D(u_noise, coord(pos)).r;

    // frag pos
    mat4 viewModel = view * model;
    vec4 viewPos = viewModel * vec4(pos, 1);
    vertex_out.position = viewPos.xyz;
    gl_Position = projection * viewPos;

    // normal
    //vertex_out.normal = normalize(cross(vertex_in[2].position - vertex_in[0].position, vertex_in[1].position - vertex_in[0].position));
    vertex_out.normal = interpolate3D(vertex_in[0].normal, vertex_in[1].normal, vertex_in[2].normal);

    // color
    if (u_showLod == 1)
        vertex_out.color = vertex_in[0].color;
    else {
        vec3 colorLow = vec3(0.7, 0.4, 0.2);
        vec3 colorMed = vec3(0.3, 0.6, 0.2);
        vec3 colorHigh = vec3(0.8, 0.8, 0.8);

        vertex_out.color = vec3((texture2D(u_noise, coord(pos)).r+1)*0.5);
    }
} 

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2) {
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2) {
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
} 

vec2 coord(vec3 pos) {
    pos = normalize(pos);
    float latitude = asin(pos.y);
    float longitude = atan(pos.x, -pos.z);
    return vec2(latitude, longitude);
}

float triplanar(vec3 pos) {
    float scale = 0.8;
    float sharpness = 4;

    float x = texture2D(u_noise, pos.zy * scale).r;
    float y = texture2D(u_noise, pos.xz * scale).r;
    float z = texture2D(u_noise, pos.xy * scale).r;
    
    vec3 n = abs(normalize(pos));
    vec3 blendw = vec3(pow(n.x, sharpness), pow(n.y, sharpness), pow(n.z, sharpness));
    blendw /= dot(blendw, vec3(1));

    return x*blendw.x + y*blendw.y + z*blendw.z;
}