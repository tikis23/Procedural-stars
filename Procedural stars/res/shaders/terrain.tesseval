#version 410 core
layout(triangles, equal_spacing, ccw) in;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

in TSC {
    vec3 position;
    vec3 normal;
    vec3 color;
} vertex_in[];

out TES {
    vec3 position;
    vec3 normal;
    vec3 color;
} vertex_out;

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2);
vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2);
void main()
{
    mat4 viewModel = view * model;
    vec4 viewPos = viewModel * vec4(interpolate3D(vertex_in[0].position, vertex_in[1].position, vertex_in[2].position), 1);

    vertex_out.position = viewPos.xyz;
    vertex_out.normal = normalize(interpolate3D(vertex_in[0].normal, vertex_in[1].normal, vertex_in[2].normal));
    vertex_out.color = normalize(interpolate3D(vertex_in[0].color, vertex_in[1].color, vertex_in[2].color));
    gl_Position = projection * viewPos;

//    float Displacement = texture(gDisplacementMap, TexCoord_FS_in.xy).x;
//    WorldPos_FS_in += Normal_FS_in * Displacement * gDispFactor;
//    gl_Position = gVP * vec4(WorldPos_FS_in, 1.0);
} 

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
} 